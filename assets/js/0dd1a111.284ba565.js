"use strict";(self.webpackChunkdev_notes=self.webpackChunkdev_notes||[]).push([[884],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=i,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,r[1]=s;for(var u=2;u<o;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},24:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=n(7462),i=(n(7294),n(3905));const o={id:"module",sidebar_position:2},r="Module",s={unversionedId:"workspace/techniques/module",id:"workspace/techniques/module",title:"Module",description:"Page describes what a typical module in a workspace should look like",source:"@site/docs/workspace/techniques/module.mdx",sourceDirName:"workspace/techniques",slug:"/workspace/techniques/module",permalink:"/dev-notes/workspace/techniques/module",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"module",sidebar_position:2},sidebar:"docs",previous:{title:"Dependency Injection",permalink:"/dev-notes/workspace/techniques/dependency-injection"},next:{title:"Health Checks",permalink:"/dev-notes/workspace/techniques/health-checks"}},l={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Don&#39;t separate modules too deeply.",id:"dont-separate-modules-too-deeply",level:2},{value:"Don&#39;t link libraries",id:"dont-link-libraries",level:2},{value:"Don&#39;t make one database provider",id:"dont-make-one-database-provider",level:2},{value:"Don&#39;t use ConfigModule in services",id:"dont-use-configmodule-in-services",level:2},{value:"Link your features in the integration layer",id:"link-your-features-in-the-integration-layer",level:2},{value:"Create an integration function in your config",id:"create-an-integration-function-in-your-config",level:3},{value:"Publish an event after user has been registered",id:"publish-an-event-after-user-has-been-registered",level:3},{value:"Summary",id:"summary",level:2},{value:"Source code",id:"source-code",level:2}],c={toc:u},d="wrapper";function p(e){let{components:t,...o}=e;return(0,i.kt)(d,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"module"},"Module"),(0,i.kt)("p",null,"Page describes what a typical module in a workspace should look like"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"During the design phase, you need to divide your application logic into modules.\nA typical developer mistake is to describe modules around an entity in a database.\nA bunch of relationships are created between your entities and, accordingly, between modules.\nMaintaining spaghetti code becomes problematic"),(0,i.kt)("p",null,"On this page I will share my vision of how the module should look like so that\nit can be easily reused and maintained in different projects."),(0,i.kt)("p",null,"One of the important properties of a module should be reusability.\nI saw how different teams wrote the same code at different times,\njust because the old code could not be reused. For example, I saw the authorization module depended\non the notification module, the 2fa module, and the dictionary module.\nAnd if I needed an authorization module, I had to drag everything else. Sounds terrific, huh?"),(0,i.kt)("p",null,"So, in order to make a module reusable, you need to keep a few rules"),(0,i.kt)("h2",{id:"dont-separate-modules-too-deeply"},"Don't separate modules too deeply."),(0,i.kt)("p",null,"If you have a typical authorization and users, it makes sense to\nwrite an authorization module and implement all the logic,\nrather than creating a separate authorization module\nand a user module that will contain a regular CRUD"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"image",src:n(399).Z,width:"5541",height:"1589"})),(0,i.kt)("p",null,"In good example, you can see that feature modules don't depend on auth module and have their own Users entity\nThat allows you to unbind auth module from your feature modules"),(0,i.kt)("h2",{id:"dont-link-libraries"},"Don't link libraries"),(0,i.kt)("p",null,"The library in Nx is what is stored in your ",(0,i.kt)("inlineCode",{parentName:"p"},"/libs")," directory. In our case library is a NestJS module.\nIt's a good rule of thumb not to link anything in your library.\nIf you need something in common between your libraries, you can create a separate folder ",(0,i.kt)("inlineCode",{parentName:"p"},"/libs/common"),"\nand store anything you want here."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"libs/\n  common/                    <---- grouping folder\n    super-duper-library/\n    not-super-library/\n  feature1/                <---- feature library\n  feature2/                <---- feature library\n")),(0,i.kt)("p",null,"The same but drawn by a professional artist"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"image",src:n(8771).Z,width:"3069",height:"943"})),(0,i.kt)("h2",{id:"dont-make-one-database-provider"},"Don't make one database provider"),(0,i.kt)("p",null,"If you have a single database provider for the entire monorepository,\nyou will not be able to simply reuse your modules in other projects.\nAt least because you will have to delete unnecessary entities in the database.\nI advice you to create database provider (like Prisma ORM) for each feature module"),(0,i.kt)("p",null,"Checkout an example ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/temarusanov/workspace/tree/main/libs/sample/src"},"here")),(0,i.kt)("h2",{id:"dont-use-configmodule-in-services"},"Don't use ConfigModule in services"),(0,i.kt)("p",null,"By using the config module in your services, you bind environment variables to your code.\nInstead, it's better to connect the config dynamically via ",(0,i.kt)("inlineCode",{parentName:"p"},".forRoot({...})")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"image",src:n(3515).Z,width:"5312",height:"1318"})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="app.module.ts"',title:'"app.module.ts"'},"import { Module } from '@nestjs/common'\n\n@Module({\n    imports: [\n        FeatureModule.forRoot({\n            enableSomething: true,\n            destroyPlanet: false\n        }),\n    ],\n    controllers: [],\n    providers: [],\n})\nexport class AppModule {}\n")),(0,i.kt)("h2",{id:"link-your-features-in-the-integration-layer"},"Link your features in the integration layer"),(0,i.kt)("p",null,"If we can't connect features with each other directly,\nthen how can we connect the application logic together? For example, if user registered (AuthModule),\nwe need to create a plan for him, the logic of which is implemented in another library (PlanModule)."),(0,i.kt)("p",null,"Link your code in an integration layer.\nAn integration layer is additional services that ties your application together.\nLet's take a look at our authorization and plans example in more depth."),(0,i.kt)("p",null,"Let's assume you have an authorization module that has a ",(0,i.kt)("inlineCode",{parentName:"p"},"signUp()")," function.\nAnd you need to create play when user has registered.\nIn order to link modules, there are two solutions"),(0,i.kt)("h3",{id:"create-an-integration-function-in-your-config"},"Create an integration function in your config"),(0,i.kt)("p",null,"When writing a module that has its own config, implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"onSignUp()")," function in it "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="libs/auth/src/lib/configs/module.config.ts"',title:'"libs/auth/src/lib/configs/module.config.ts"'},"export const AUTH_CONFIG = 'AUTH_CONFIG'\n\nexport interface AuthConfig {\n    databaseUrl: { ... }\n\n    onSignUp: (user: User) => Promise<void>\n}\n")),(0,i.kt)("p",null,"And then add it to your ",(0,i.kt)("inlineCode",{parentName:"p"},"signUp()")," function in your service"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="libs/auth/src/lib/services/auth.service.ts"',title:'"libs/auth/src/lib/services/auth.service.ts"'},"@Injectable()\nexport class AuthService {\n    constructor(\n        @Inject(AUTH_CONFIG)\n        private readonly config: AuthConfig\n    ) {}\n\n    async signUp() {\n        // some sign up logic here\n\n        await this.config.onSignUp(user)\n\n        return user\n    }\n}\n")),(0,i.kt)("p",null,"Then create an intergration service in your application (",(0,i.kt)("inlineCode",{parentName:"p"},"/apps/my-application"),")"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="apps/my-application/src/lib/integrations/auth.integration.ts"',title:'"apps/my-application/src/lib/integrations/auth.integration.ts"'},"@Injectable()\nexport class AuthConfigIntegration implements AuthConfig {\n    constructor(\n        private readonly planService: PlanService\n    ) {}\n\n    async onSignUp(user: User) {\n        await this.planService.createPlan(user.userId)\n    }\n}\n")),(0,i.kt)("p",null,"And inject ",(0,i.kt)("inlineCode",{parentName:"p"},"AuthConfigIntegration")," in your AuthModule ",(0,i.kt)("inlineCode",{parentName:"p"},".forRootAsync()")," function"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"For now, I don't have ",(0,i.kt)("inlineCode",{parentName:"p"},".forRootAsync()")," function in my workspace. But you can find docs about that in\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/fundamentals/dynamic-modules"},"NestJS"))),(0,i.kt)("h3",{id:"publish-an-event-after-user-has-been-registered"},"Publish an event after user has been registered"),(0,i.kt)("p",null,"Add a publish function to your ",(0,i.kt)("inlineCode",{parentName:"p"},"signUp()")," function in your service.\nYou can use RxJs, NATS, RMQ, Events, etc."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="libs/auth/src/lib/services/auth.service.ts"',title:'"libs/auth/src/lib/services/auth.service.ts"'},"@Injectable()\nexport class AuthService {\n    constructor(\n        private readonly authEventService: AuthEventStream\n    ) {}\n\n    async signUp() {\n        // some sign up logic here\n\n        await this.authEventService.publish({\n            pattern: 'USER_REGISTERED',\n            data: user\n        })\n\n        return user\n    }\n}\n")),(0,i.kt)("p",null,"Then create an intergration service in your application (",(0,i.kt)("inlineCode",{parentName:"p"},"/apps/my-application"),")"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="apps/my-application/src/lib/integrations/auth.integration.ts"',title:'"apps/my-application/src/lib/integrations/auth.integration.ts"'},"@Injectable()\nexport class AuthConfigIntegration {\n    constructor(\n        private readonly planService: PlanService,\n        private readonly authEventService: AuthEventStream\n    ) {}\n\n    async onApplicationBootstrap() {\n        this.authEventService.subscribe('USER_REGISTERED', (data) => {\n            await this.planService.createPlan(data.userId)\n        })\n    }\n}\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"This is not a full code. It can depends on what you are using in your project. For example, for NATS\nimplementation can differ from that, but the approach is the same")),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"All of these tips will help keep your modules standardized and reusable.\nOf course, it all depends on your preferences and coding standards.\nMaybe this won't work for you. For a long time I did not understand\nwhy modules were needed in the NestJS,\nuntil I realized their main advantage: reusing code and packing logic into modules.\nBut in order to achieve this, you will have to learn how to make them independent."),(0,i.kt)("h2",{id:"source-code"},"Source code"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/temarusanov/nx/tree/main/libs/sample"},"Don't trust, verify!"))))}p.isMDXComponent=!0},399:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/module-1-c193e54d796c071b0f1b37770b0aa9bd.png"},8771:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/module-2-7091503dc328e6f513ac1b80add5cb8a.png"},3515:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/module-3-b71ac1a2343a81584ba91c97be22b5eb.png"}}]);